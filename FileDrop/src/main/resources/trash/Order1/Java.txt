
									Threads


				Запуск потоков:


#Способ 1

Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. 
Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит 
выполнение, когда завершится его метод run().

___________________________________________________________________________________________________
class SomeThing			
implements Runnable	
{
	public void run()	
	{
		System.out.println("Привет из побочного потока!");
	}
}

public class Program			
{
	static SomeThing mThing;
	
	public static void main(String[] args)
	{
		mThing = new SomeThing();				

		Thread myThready = new Thread(mThing);
		myThready.start();		

		System.out.println("Главный поток завершён...");
	}
}
___________________________________________________________________________________________________

#Способ 2

Создать потомка класса Thread и переопределить его метод run(). хреновый способ с точкизрения ооп.

___________________________________________________________________________________________________
class AffableThread extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Привет из побочного потока!");
	}
}

public class Program
{
	static AffableThread mSecondThread;
	
	public static void main(String[] args)
	{
		mSecondThread = new AffableThread();
		mSecondThread.start();	
		
		System.out.println("Главный поток завершён...");
	}
}
___________________________________________________________________________________________________


				Завершение процесса и демоны


В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже 
завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный 
поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение 
процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих 
процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon()


				Завершение потоков


В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() 
завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий 
поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне 
нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит 
некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей 
ошибке.

Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. 
Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по 
сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток 
может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. 
Описание реакции на сигнал завершения потока лежит на плечах программиста.

Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство)


				Interruption


Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом 
прерывания. Установить этот флаг можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя 
способами. Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод 
bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод 
возвращает состояние флага и сбрасывает его. Заметьте что Thread.interrupted() — статический метод класса Thread, и его вызов 
возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока 
и позволяет потоку проверить своё состояние прерывания.

Заметьте что методы sleep() и join() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий 
их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.


				Метод Thread.sleep()


Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван. Во время 
выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод 
sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен 
прерыванием (в этом случае он сгенерирует исключение InterruptedException).

___________________________________________________________________________________________________
Thread.sleep(1500); 		//Ждет полторы секунды
Thread.sleep(2000, 100);  	//Ждет 2 секунды и 100 наносекунд
___________________________________________________________________________________________________

Несмотря на то, что метод sleep() может принимать в качестве времени ожидания наносекунды, не стоит принимать это всерьез. Во многих 
системах время ожидания все равно округляется до миллисекунд а то и до их десятков.


				Метод yield()


Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, 
например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. 
В этом случае можно поместить проверку события и метод Thread.yield() в цикл:

___________________________________________________________________________________________________
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}
___________________________________________________________________________________________________
yield лишь передаёт некоторую рекомендацию планировщику потоков Java, что данному потоку можно дать меньше времени исполнения. 
Но что будет на самом деле, услышит ли планировщик рекомендацию и что вообще он будет делать — зависит от реализации JVM и 
операционной системы.


				Метод join()


В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join(). 
Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в 
главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.

Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае join() возвращает 
управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания. Подобно методу Thread.sleep() метод join 
может ждать в течение миллисекунд и наносекунд – аргументы те же.


				Приоритеты потоков

Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого 
означает больший приоритет. Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают 
процессорное время только тогда, когда их более привилегированные собратья простаивают.

Работать с приоритетами потока можно с помощью двух функций:

	void setPriority(int priority) – устанавливает приоритет потока.
	Возможные значения priority — MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY.

	int getPriority() – получает приоритет потока.


				Некоторые полезные методы класса Thread


boolean isAlive() — возвращает true если myThready() выполняется и false если поток еще не был запущен или был завершен.

setName(String threadName) – Задает имя потока.

String getName() – Получает имя потока.

Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, какой поток выполняет некоторое действие. 
Иногда это бывает полезным.

static Thread Thread.currentThread() — статический метод, возвращающий объект потока, в котором он был вызван.

long getId()– возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.


				Синхронизация потоков


Если блок кода помечен ключевым словом synchronized, это значит, что блок может выполняться только одним потоком одновременно.

Синхронизацию можно реализовать по-разному. Например, создать целый синхронизированный метод:

___________________________________________________________________________________________________
public synchronized void doSomething() {

   //...логика метода
}
___________________________________________________________________________________________________

Или же написать блок кода, где синхронизация осуществляется по какому-то объекту:

___________________________________________________________________________________________________
public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}
___________________________________________________________________________________________________

Смысл прост. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает мьютекс 
объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод вынуждены ждать, пока предыдущий поток не 
завершит свою работу и не освободит монитор.

Эти два способа записи означают одно и то же:

___________________________________________________________________________________________________
public void swap() {

   synchronized (this)
   {
       //...логика метода
   }
}


public synchronized void swap() {

   }
}
___________________________________________________________________________________________________

	Особенности синхронизации в статических методах

В первом случае создаешь синхронизированный блок кода сразу же при входе в метод. Он синхронизируется по объекту this, 
то есть по текущему объекту. А во втором примере вешаешь слово synchronized на весь метод. Тут уже нет нужды явно указывать 
какой-то объект, по которому осуществляется синхронизация. Раз словом помечен целый метод, этот метод автоматически будет 
синхронизированным для всех объектов класса.

___________________________________________________________________________________________________
class MyClass {
   private static String name1 = "Оля";
   private static String name2 = "Лена";

   public static void swap() {

       synchronized (MyClass.class) {
           String s = name1;
           name1 = name2;
           name2 = s;
       }
   }

}
___________________________________________________________________________________________________

https://javarush.ru/groups/posts/2048-threadom-java-ne-isportishjh--chastjh-ii---sinkhronizacija
https://javarush.ru/groups/posts/1994-sinkhronizacija-potokov-operator-synchronized




									Stream API




	|	   |  элементы  | Промежуточные |  элементы   | Терминальный |
	| Источник | ---------> | Операторы	| --------->  | Оператор     |
	|	   |		|		|	      |		     |
 

Пустой стрим: Stream.empty()
Стрим из List: list.stream()
Стрим из Map: map.entrySet().stream()
Стрим из массива: Arrays.stream(array)
Стрим из указанных элементов: Stream.of("1", "2", "3")

Операторы можно разделить на две группы:

Промежуточные (“intermediate”, ещё называют “lazy”) — обрабатывают поступающие элементы и возвращают стрим. 
Промежуточных операторов в цепочке обработки элементов может быть много.

Терминальные (“terminal”, ещё называют “eager”) — обрабатывают элементы и завершают работу стрима, так что 
терминальный оператор в цепочке может быть только один.

				Промежуточные операторы

filter(Predicate predicate) фильтрует стрим, пропуская только те элементы, что проходят по условию (Predicate 
встроенный функциональный интерфейс, добавленный в Java SE 8 в пакет java.util.function. Проверяет значение на 
“true” и “false”);

map(Function mapper) даёт возможность создать функию с помощью которой мы будем изменять каждый элемент и 
пропускать его дальше (Функциональный интерфейс Function<T,R> представляет функцию перехода от объекта типа 
T к объекту типа R)

flatMap(Function<T, Stream<R>> mapper) — как и в случае с map, служат для преобразования в примитивный стрим

___________________________________________________________________________________________________
String[] array = {"Java", "Ruuuuussshhh"};
Stream<String> streamOfArray = Arrays.stream(array);
streamOfArray.map(s->s.split("")) //Преобразование слова в массив букв
        .flatMap(Arrays::stream).distinct() //выравнивает каждый сгенерированный поток в один поток
        .collect(Collectors.toList()).forEach(System.out::println);
___________________________________________________________________________________________________


Тот же метод flatMap, но для Double, Integer и Long:
flatMapToDouble(Function mapper)
flatMapToInt(Function mapper)
flatMapToLong(Function mapper)
И ещё пример для сравнения, flatMap:

___________________________________________________________________________________________________
Stream.of(2, 3, 0, 1, 3)
        .flatMapToInt(x -> IntStream.range(0, x))
        .forEach(System.out::print);// 010120012
IntStream.range(0,x) – выдаёт на поток элементов с 0 (включительно) по x (не включительно);
___________________________________________________________________________________________________

map:

___________________________________________________________________________________________________
Stream.of(2, 3, 0, 1, 3)
        .map(x -> IntStream.range(0, x))
        .forEach(System.out::print);//перечень стримов(потоков);
___________________________________________________________________________________________________

limit(long maxSize) – ограничивает стрим по количеству элементов:

___________________________________________________________________________________________________
stream.limit(5).forEach(x -> System.out.println(x));
___________________________________________________________________________________________________

skip(long n) – пропускаем n элементов:

stream.skip(3).forEach(x -> System.out.println(x));

sorted(Comparator comparator) – сортирует стрим (сортировка как у TreeMap):
___________________________________________________________________________________________________
stream.sorted().forEach(x -> System.out.println(x));
___________________________________________________________________________________________________

distinct() — проверяет стрим на уникальность элементов(убирает повторы элементов);

dropWhile(Predicate predicate) — пропускает элементы которые удовлетворяют условию (появился в 9 java, 
Функциональный интерфейс Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то 
возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T:
___________________________________________________________________________________________________
Predicate<Integer> isPositive = x -> x > 0;
       System.out.println(isPositive.test(3)); // true
       System.out.println(isPositive.test(-9)); // false
___________________________________________________________________________________________________


				Терминальные операторы

forEach(Consumer action) – аналог for each (Consumer<T> выполняет некоторое действие над объектом типа T, 
при этом ничего не возвращая);

count() – возвращает количество елементов стрима

collect(Collector collector) – метод собирает все элементы в список, множество или другую коллекцию, 
сгруппировывает элементы по какому-нибудь критерию, объединяет всё в строку и т.д.

Optional min(Comparator comparator)/ Optional max(Comparator comparator) ищет минимальный/максимальный 
элемент, основываясь на переданном компараторе;

findFirst() – вытаскивает первый элемент стрима

allMatch(Predicate predicate) — возвращает true, если все элементы стрима удовлетворяют условию. Если 
встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор 
перестаёт просматривать элементы и возвращает false

anyMatch(Predicate predicate) — вернет true, если хотя бы один элемент стрима удовлетворяет условию predicate




									SQL



				Типы данных:


Name		  | Range
		  |
smallint	  | 2^16->-32768 to 32767
integer		  | 2^32						целые числа
bigin		  | 2^64

decimal/numeric	  | 3.4*10^38	// используется для денежных расчётов
real/float4	  | 6 знаков после запятой		  		не целые числа
double presision/ | 15 знаков после запятой
float8/float

smallserial	  | 1 to 32767
serial		  | 1 to 21474483647 автоинкрементируется
				     (увеличивается на 1)		положительные целые
bigserial	  | 1 to ~9*10^16

char		  | строка фиксированной длинны, более длинные строки приводят к ошибке, 
		  | меньшие добиваются пробелами
varchar		  | строка фиксированной длинны, более длинные строки приводят к ошибке, 
		  | меньшие не добиваются
text		  | строки любой длинны

Boolean/bool	  | True/False

date		  | почти 5 тысяч до нэ. до 294276
time		  | 00.00.00-24.00.00
timestamp	  | хранит дату и время
interval	  | разница между двумя timestamp
timestamptz	  | timestamp + хранит часовой пояс

другие: Arrays, JSON, XML ...


				Операции с БД


	Создание базы данных

CREATE DATABASE test
    WITH
    OWNER = postgres		// значения по умолчанию,
    ENCODING = 'UTF8'		// при создании не обязательно казывать
    CONNECTION LIMIT = -1;	// 


	Удаление базы данных

Сначала отключиться от неё, заем DROP DATABASE name


				Работа с таблицами


	Создание таблицы

CREATE TABLE table_name
(
    publisher_id integer PRIMARY KEY	// PRIMARY KEY - postgres следит, чтобы в каждой строке было своё число
    org_name varchar(128) NOT NULL,
    address text NOT NULL
    
)

	Изменение таблицы

ALTER TABLE table_name далее:
	ADD COLUMN column_name data_type
	RENAME TO new_table_name
	RENAME old_column_name TO new_column_name
	ALTER COLUMN column_name SET DATA TYPE data_type
	
	Удаление таблицы

DROP TABLE table_name			удаляет таблицу, если она есть, иначе ошибка
DROP TABLE IF EXIST table_name		удаляет таблицу с именем name, если таковая имеется

	Очистка таблицы

TRUNCATE TABLE table_name не может удалить данные, на которые есть ссылки из других таблиц
по усолчанию не сбрасывает автоинкремент, для сброса нужно добавить: RESTART IDENTITY

	Удаление колонки
	
DROP COLUMN column_name 


				PRIMARY KEY


обеспечивает уникальность по этому полю те если id - primary, то (id, name1) и (id, name2)
не уникальные. Primary key не NULL. Primary похож по своему действию на UNIQUE NOT NULL, но
в отличии от него он может быть в таблице только один.


				FOREIGN KEY


блягодаря этому мы можем ограничить значения
(2 таблицы книги и аторы, в таблице книги хранится id атора, написашего его. Благодаря 
внешнему ключу в id таблицы книг не может быть id, которого нет в табл авторов)
Внешний ключ устанавливается для столбца из зависимой, подчиненной таблицы 
(referencing table), и указывает на один из столбцов из главной таблицы 
(referenced table). Как правило, внешний ключ указывает на первичный ключ 
из связанной главной таблицы.
FOREIGN KEY (стобец1, столбец2, ... столбецN) 
    REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
    [ON DELETE {CASCADE|RESTRICT}]
    [ON UPDATE {CASCADE|RESTRICT}]
ON DELETE и ON UPDATE уточняют поведение при удалении или обновлении данных.


				CHECK
позволяет сделать ограничения на вносимые в таблицу данные
price decimal CONSTRAINT CHK_book_price CHECK (price>= 0)


				DEFAULT


задаёт значения по умолчанию
status char DEFAULT 'r'


				CONSTRAINT 


ограничения. у каждого констрейнта есть имя, его можно узнать через
SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'table_name' - имя таблицы
AND table_schema = 'public'	- если таблица находится в публичной схеме
AND column_name = 'column_name' - узнаём название для конкретного столбца

constrint нужен, чтобы дать имя ограничению (при создании/изменении таблицы)
CONSTRAINT our_constraint_name PRIMARY KEY(column_name)
	
удалить constreint
ALTER TABLE table_name DROP CONSTRAINT constraint_name


				CREATE SEQUENCE(Последовательности)


	создание SEQUENCE 

serial основан на полседовательностях, благодаря этому у него есть сфвойство автоинкремента.
CREATE SEQUENCE seq1;
при создании можно просписать такие параметры, как:
	INCREMENT 2	// инкремен позволяет задать значение, на которое будет увеличиваться 
			   число, по умолчанию 1
	MINVALUE  0	// минимальное значение, которое может принимать(включительно)
	MAXVALUE 128	// максимальное значение (включительно)
	START WITH 0	// первое значение

	операции с SEQUENCE 

SELECT nextval('seq1'); 		// генерирует следующее значение
SELECT currval('seq1'); 		// возвращает текущее значение
SELECT lastval();			// возвращает последнее значение, сгенерированное 
					   кокой-либо последовательностью в текущей сессии
SELECT setval('seq1',16, true )		// изменяет currval (в данном случае, currval 
					   сразу станет 16)
			 false)		// не изменяет currval 
					   (в данном случае, currval останется прежним, 
					   а вызов nextval даст 16)

	изменение SEQUENCE 

при помощи ALTER можно переименовать и перезапустить
ALTER SEQUENCE seq1 RESTART WITH 16  // перезапускает, 16 будет присвоена после вызова nextval

drop sequence if exists seq3 - удаление

	использование в таблицах 1.05.00

пусть book_id объявлен как integer, можно сделать его автоинкрементируемым. 
CREATE SEQUENCE IF NOT EXISTS book_book_id_seq START WITH 1 OWNED BY book.book_id
мы создали очередь принадлежащую book_id таблицы book, но этого не достаточно, нужно
прописать default
ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('book_book_id_seq ')
теперь всё будет работать корректно.

	Беды с serial и новый синтексис

может возникнуть проблема с типом данных serial, если у нас есть данные внесённые с 
использованием авто инкремента, после чего мы втавим значение и пропишем там значение
переменной, то при следующей вставке с использованием автоинкремента мы получим ошибку
*урок 5 1.13.40 (это просто прикол sequence).
для решения проблем с serial был введён новый синтексис:
book_id serial NOT NULL --> book_id int GENERATED ALWAYS AS IDENTITY(свойства, как при 
			    создании seq) NOT NULL
			    при попытки задать это значение явно(руками) выыбрасывается 
			    ошибка. можно обойтипри помощи добавления OVERRIDING SYSTEM VALUE

			--> book_id int GENERATED BY DEFAULT IDENTITY NOT NULL
			    аналогично


				SELECT


SELECT колонки, *- все FROM book


	Математические операции

+ сложение		* умножение		^  степень			и тд
- вычитание		/ деление		|/ квадратный корень

SELECT product_id, product_name,unit_ptice*units_in_stock FROM product 

 	DISTINCT

позволяет брать в выборку только уникальные значения
SELECT DISTINCT address FROM publisher

	COUNT

Считает кол-во эллементов
SELECT COUNT(DISTINCT address) FROM publisher

	WHERE

фильтрует полученные данные в соответствии с условием comdition
SELECT * FROM toble WHERE comdition
SELECT * FROM publisher WHERE address = 'NY'

	Операторы сравнения
= равенство	>=
> больше	<> не равно(можно использовать!=)

	Логические операции AND, OR

SELECT * FROM publisher WHERE publisher_id>=2 OR address='NY'
SELECT * FROM publisher WHERE publisher_id>=2 AND address='NY'
нельзя забывать про скобки

	BETWEEN

SELECT * FROM publisher WHERE publisher_id BETWEEN 2 AND 3
2 и 3 включительно

	IN,NOT IN

позволяет проверить равенство/не сразу для нескольких элементов
SELECT * FROM publisher WHERE address IN('NY', 'Novosibirsk')
SELECT * FROM publisher WHERE address NOT IN('NY', 'Novosibirsk')

	ORDER BY

позволяет упорядочить полученнык данные, по умолчанию сортирует по возрастанию(ASC), для
сортировки по убыванию добавить DESC
SELECT DISTINCT(*) FROM publisher ORDER BY address
SELECT DISTINCT(*) FROM publisher ORDER BY address DESC

можно сортировать по несколким колонкам, при этом сортировка по 2 колонке не будет нарушать
сортировку по первой
SELECT * FROM publisher ORDER BY address DESC, publisher_id DESC

	MIN, MAX, AVG, SUM

select min(publisher_id) from publisher
select max(publisher_id) from publisher
select avg(publisher_id) from publisher
select sum(publisher_id) from publisher

	LIKE

% - 0,1 или более символов
_ - ровно один символ
LIKE 'U%' - строки начинающиеся на U
select * from publisher where org_name like 'a%' order by address desc

	LIMIT

идёт самым последним, ограничивает число выдаваемых записей
select * from publisher  where org_name like 'a%' order by address desc limit 1

	IS NULL, IS NOT NULL

провкра на NULL
select * from publisher  where  address is null
select * from publisher  where  address is not null

	GROUP BY

группирует элементы
select org_name,count(*) from publisher where address is not null group by org_name

	HAVING

постфильтр похож на WHERE, но распологается после GROUP BY и перед ORDER BY
select org_name,count(*) from publisher 
where address is not null 
group by org_name
HAVING org_name like '%d%'
order by count(distinct address) desc

	UNION, INTERSECT, EXCEPT

union объединфнт результаты 2 select при этом устраняя дупликаты
union all как union, но не удаляет повторения
select book from authors where name like 'T%'
union
select title from book

intersect выводит пересечения
select book from authors where name like 'T%'
intersect
select title from book

except исключая. Работает только для запросов
select title from book
except
select book from authors where name like 'T%'

	OUTER JOIN, INNER JOIN = JOIN

OUTER JOIN или внешнее соединение позволяет возвратить все строки одной или двух таблиц, которые участвуют в соединении.

Outer Join имеет следующий формальный синтаксис:
SELECT столбцы
FROM таблица1
    {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1
    [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]...
Перед оператором JOIN указывается одно из ключевых слов LEFT, RIGHT или FULL, которые определяют тип соединения:

LEFT: выборка будет содержать все строки из первой или левой таблицы
RIGHT: выборка будет содержать все строки из второй или правой таблицы
FULL: выборка будет содержать все строки из обеих таблиц

Inner Join объединяет строки из дух таблиц при соответствии условию. Если одна из таблиц содержит строки, которые не 
соответствуют этому условию, то данные строки не включаются в выходную выборку. Left Join выбирает все строки первой 
таблицы и затем присоединяет к ним строки правой таблицы.

	SELF JOIN

полезно, когда в таблице есть ссылки на своё поле

create table employee(
employee_id INT Primary key,
first_name ...
second_name ...
manager INT, foreign key (manager_id) references employee (employee_id)
);

select e.first_name || ' ' || e.last_name as employee, |
       m.first_name || ' ' || m.last_name as manager   | задание псевдонимов
from employee e 
left join employee m on m.employee_id = e.manager_id
order by manager

Результат:		| employee | manager |
			| name i   | name 1  |
			| name j   | name 2  | и тд

	USING & NATURAL JOIN

using позволяет упростить запись в join, основываясь на схожести имён

select first_name, order_date from orders
join order_details on orders.order_id = order_details.order_id

равносильно 

select first_name, order_date from orders
join order_details using(order_id)

NATURAL JOIN работает как iner join, проходит по всем столбцам проименованным одинаково

select first_name, order_date from orders
natural join order_details

	Псевдонимы(AS)

select count(*) as employees_count - просто поменяет название колонки, ими не получится
from employees 			     в where, можно использовать в GROUP BY и ORDER BY

	Подзапросы

мы можем в условия(where) пихать целые запросы, зачастую без этого можно обойтись, используя
join

select city,count(distinct name) from authors 
where book in (select title from books ) 
group by city


	WHERE EXISTS

возращает true, если подзапрос вернул хотя бы 1 строку

select id,name, book from authors where exists(select id from authors where id>10)

	ANY, ALL

позволяют сопоставлять результаты подзапроса с конкретным полем

	INTO
можно делать селект в другую таблицу. эта таблица создастся. при этом дополнить 
таблицу такой же операцией нельзя, нужно писать insert, в котором уже использовать
select.(пример ниже)
SELECT * INTO best_authors FROM authors WHERE rating > 4,7
INSERT INTO best_authors SELECT * FROM authors WHERE rating > 4,5 and raiting <=4,7


				INSERT


INSERT INTO table_name (columns_mames)VALUES (values)


				UPDATE


UPDATE authors SET full_name = 'Roman', raiting = 5
WHERE authors_id = 8  // лучше использовать первичный ключ


				DELETE


DELETE FROM autors WHERE raiting<3
удалить всё DELETE FROM autors это записывается в логи, TRANCATE - нет








								SPRING
1) Spring Core
2) Spring boot
3) Spring MVC
4) timelife?




			1) Spring  Core




	Инверсия управления (IoC)

class ClassicalMusic{
....
}

class MusicPlayer{
	private ClassicalMusic classicalMusic

	public MusicPlayer(){
		classicalMusic = new ClassicalMusic();	
	}
	....
}

Проблемы:
	1)MusicPlayer заточен на работу только с ClassicalMusic, можно решить введением
абстрактного класса или интерфейса для музыкальных жанров
	2)Объекты создаются вручную из за этого для создания новых (изменения старфх) нужно 
лезть в код. Лучше вынести объекты в конфигурационный файл при помощи Spring Framework(Bean)

* Bean

это просто Java объект, созданный при помощи Spring
<bean id="testBean"				- имя бина
      class="com.company.TestBean">		- клас бина
      <constructor_arg value="Neil"/>		- аргументы конструктора
</bean>

	3)MusicPlayer сам создаёт свои зависимости, следует использовать принцип IoC (объект
не создаёт своих зависимостей, он их получает извне)

После всех дороботок:

class ClassicalMusic implements Music {
....
}

class MusicPlayer{
	private Music music; 

	public MusicPlayer(Music music){
		this.music = music;	
	}
	....
}
	4)Возникла после внедрения IoC, а именно, объект подаваемый в конструктор надо где-то 
создавать. Решается при помощи Dependency Injection (DI). Этим занимается Spting


	Dependency Injection (DI)


	Конфигурация при помощи xml
	---------------------------

<bean id="musicBean"
	class="org.example.ClassicalMusic">
</bean>

<bean id="musicPlayer"
	class="org.example.MusicPlayer">
	<constructor-arg ref="musicBean"/>
</bean>

можно сделать таким образом. Получить элементы из крнтекста Spring можно при помощи

ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
        );
MusicPlayer player = context.getBean("musicPlayer", MusicPlayer.class);
player.playMusic();
context.close();


усли мы хотим передать значение в setter-е, то <constructor-arg ... надо заменить на
<property name="name" value="Some name"/> значение поля name совпадает с названием seter-а


если мы хотим импортировать значения из другого файла, то нужно создать файл .properties,
импортировать его:
 <context:property-placeholder location="classpath:musicPlayer.properties"/>
подставить значения:
<property name="name" value="${musicPlayer.name}"/>


В сетеры можно передавать не только отдельные элементы, но и множество элементов, для этого
<bean id="tasks" class="java.util.ArrayList">
        <constructor-arg>
            <list>
                <ref bean="classicalMusicBean" />
                <ref bean="rockMusicBean" />
                <ref bean="duftPankMusicBean"/>
            </list>
        </constructor-arg>
    </bean>	(пример с ArrayList)

Scope

scope задаёт то, как Spring будет создавать наши бины
Singleton - scope, используемый по умолчанию:
	* По умолчанию создаётся один объект( он создаётся до вызова метода getBean())
	* При всех вызовах getBean() возвращается ссылка на один и тот-же единственный 
	объект
Prototype - создаёт новый объект при каждом вызове getBean()
есть ещё request, session, global-session, но об этом позднее
<bean id="musicPlayer"
	  class="org.example.MusicPlayer"
	  scope="prototype">				-- прописанна переменная scope
	<property name="musicList" ref="tasks"/>
	<property name="name" value="${musicPlayer.name}"/>
	<property name="volume" value="${musicPlayer.volume}"/>
</bean>

init-method, destroy-method, factory method

Жизнь Бина:
 _____________      _______________      ________________      __________
|запуск Spring|	   |Запускается    |    |Создаётся объект|    |Dependency|
|приложения   | -> |Sprig контейнер| -> |Бина		 | -> |injection | ->
|_____________|    |_______________|    |________________|    |__________|
   ____________________       _____________      _____________      ____________________
   |Вызывается указанный|    |Бин готов к  |    |Использование|    |Вызывается указанный|
-> |init-method	        | -> |использование| -> | 	      | -> |destroy-method      | ->
   |____________________|    |_____________|    |_____________|    |____________________|
    ________________
   |Остановка Spring|
-> |приложения      |
   |________________|
init-method - запускается в ходе иницилизации бина, зачастую используется для инициализации
ресурсов, обращения к внещним файлам, запуска БД
destroy-method- запускается в ходе уничтожения бина, зачастую используется для очищения 
ресурсов, закрытия потоков ввода-вывода, закрытия доступа к БД
<bean id="classicalMusicBean"
	class="org.example.ClassicalMusic"
	init-method="doMyInit"			--совпадает с названием метода в классе
	destroy-method="doMyDestroy">
</bean>
Тонкости init и destroy методов:
	1) у этих методов может быть любой модификатор доступа
	2) может быть любое возвращаемое значение, но получить его нельзя
	3) название метода может быть любым
	4) эти методы НЕ должны принимать на вход аргументы
	5) для бинов со scope "prototype" не вызывет destroy метод, при каждом вызове
	   getBean() вызывается init метод
factory-method - если объекты класса создаются фабричным методом, то можно определить 
factory-method
<bean id="classicalMusicBean"
	class="org.example.ClassicalMusic"
        factory-method="getClassicalMusic">
</bean>
мы просто сделали конструктор по умолчанию приватным и теперь создать новый объект можно только через get

	Конфигурация при помощт xml + Анотации
	--------------------------------------

Аннотоции - это специальный вид коментариев,с помощью которых можно:
	1) передавать инструкции для Java компилятора
	2) передавть инструкции для анализаторов исходного кода
	3) передавать методанные, которые могут быть использованны либо моим Java приложением,
	   либо другими приложениями или фреймворками
Зачем использовать аннотации:
	1) короче, чем xml конфигурация
	2) удобнее, чем xml
	3) повышается читабельность кода
Если мы хотим, чтобы Spring сделал бин из класса, то перед классом нужно написать анотацию
@Component("BeenId"). Можно указать id, если его не указывать, то название бина - название 
класса с маленькой буквы. Чтобы Spring просканировал файлы необходимо в xml прописать:
<context:component-scan base-package="org.example"/>
@Autowired - отвечает за DI. Spring сканирует все классы с анотацией @Component и создаёт
бины, после Spring сканирует все бины и проверяет подходит ли какой-нибудь в качестве 
зависимости, где мы указали @Autowired:
	1)Если нашёлся один подходящий бин, то он внедряется в качестве зависимости
	2)Если не нашлось, то ошибка
	3)Если нашлось несколько, то неоднозначность (ошибка, но можно бороться)
*@Autowired можно вешать на любую функцию и на поля. Если повешать на функцию,
которая не обеспечивает зависимость, то ошибка
*@Qualifier("BeenId") - позволяет нам решить проблему с несколькими подходящими в @Autowired
бинами. Нужно просто приписать имя нужного. При использовании в конструкторе нужно писать:
@Autowired
public MusicPlayer(@Qualifier("classicalMusicBean") Music music){
	this.music = music;
}
В остальных случаях достаточно прописывать после @Autowired
*@Values - позволяет нам импортировать значения из других файлов .properties. всё так же
нужно в xml прописать property-placeholder.
@value("${musicPlayer.name}")
private String name;
*@Scope позволяет задавать scope по умолчанию всё так же singleton
@Scope("prorotype")
public class ClassName{ ... }
*@PostConstruct и @PostDestroy указывают init-method и destroy-method
@PostConstruct
public void doMyInit(){ .... }

	Конфигурация с помощью Java кода
	--------------------------------

*@Configuration - помечаем Java класс,который мы хотим использовать для конфигурации Spring
приложения. Пустой класс = пустому по функционалу xml файлу.
для каждого xml тега есть соответствующая анотация, так для context:component-scan это
@ComponentScan(пишется для класса), для <bean ... - это @Bean.
*Для использования конфигурационного Java файла нужно успользовать вместо 
ClassPathXmlApplicationContext AnnotationConfigApplicationContext(SpringConfig.class)
public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
               SpringConfig.class
        );
        
        ClassicalMusic music = context.getBean("classicalMusicBean", ClassicalMusic.class);
        MusicPlayer player = context.getBean("musicPlayer", MusicPlayer.class);
        player.playMusic();
	context.close();
}
Ручное внедрение зависимости выглядит так:
@Configuration
public class SpringConfig{

	@Bean
	public ClassicalMusic musicBean(){
		return new ClassicalMusic();
	}

	@Bean
	public MusicPlayer musicPlayer() {
		return new MusicPlayer(musicBean());
	}
}



singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для бинов без сохранения состояния(stateless)
prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы используете web-aware ApplicationContext
global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании portlet контекста). Действует, только если вы используете web-aware ApplicationContext
application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете web-aware ApplicationContext
				Spring MVC




Spring MVC - один из компонентов Spring framework, который позволяет разрабатывать web.
Spring MVC предлагает разработку web приложений с использованием архитектуры Model-View-
-Controller
Model - логика работы с данными
View - логика представления(интерфейс web-а)
Controller - логика навигации, обработка запросов
Spring MVC приложение состоит из:
	1)Обычные Java классы(контроллеры, модели и тд.)
	2)Набор HTML страниц
	3)Spring конфигурация(xml, анотации)
Сначала запрос попадает в DispatcherServlet, он отвечает за отправление запроса нужному 
контроллеру. Нам не нужно реализовывать DispatcherServlet. Мы реализуем только Модели,
Контроллеры и Представления.

	Controller
	----------

Обрабатывает запросы от пользователей
Обменивается данными с моделью
Показывает пользователю правильное представление
Переадресовывает пользователя на другие страницы
...
Помечается анотацией контроллер( @Controller ), которая наследуется от анотации @Component.
В контроллере может быть несколько методов, обычно каждый метод соответствует одному URL-у.
Обычно методы возвращают строку (String) - название представления, которое надо показать 
пользователю, у методов могут быть любые названия.
@Controller
public class HelloWorldController {
	@GetMapping("/hello-world")
	public void sayHello(){
		return "hello_world";
	}
}


	Маппинги


1)@GetMapping
2)@PostMapping
3)@PutMapping
4)@DeleteMapping
5)@PatchMapping
6)@RequestMapping(method = RequestMethod.GET) - Устаревший

Эти маппинги связывают контроллер с адресом, по которому можно к этому методу обратиться. 
5 различных видов маппинга - в зависимости от того, какой HTTP запрос должен прийти в этот
метод контроллера.
@RequestMapping может использоваться на классе, в этом случае URL адреса всех методов будут
обязательно иметь в себе /people в начале
@Controller
@RequestMapping("/people")
public class PersonController { .... }

HTTP запросы:
	1) Get - "Получить" 
		Самый использумый запрос(переход по адресу, преход по ссылке ...)
		Идемпотентный(ничего не меняет на сервере) 
		Тело запроса пустое 
		Параметры Get запроса передаются в URL после знака ? в формате ключ=значение,
несколько параметров(пар ключ=значение) разделяются знаком &. Параметры нужны для передачи 
информации от клиента к серверу во время запроса.
	2) Post - "Публиковать"
		Цель запроса изменить что-то на сервере
		Часто используется для отправки данных с веб форм
		Все параметры хранятся в теле запроса
		Тело запроса может содержать различные данные
		URL не содержит параметров
		Может передавать различные данные
HTTP ответы
	1XX - информирование
	2XX - всё ок
	3XX - перенаправление
	4XX - ошибка клиента
	5XX - ошибка сервера


	Обработка параметров Get запросов

Параметры Get - запроса в Spring можно получить 2 способами

1) с помощью объекта		@GetMapping("/hello")
HttpServletRequest		public String helloPage(HttpServletRequest request){
					String name = request.getParameter("name");
					return "hello"
				}
Если в запросе не указать данных getParameter вернёт null

2) с помощью аннотации		@GetMapping("/hello")
@RequestParam			public String helloPage(@RequestParam("name") String name){
					return "hello"
				}
Если в запросе не указать данных будет вызвана ошибка, чтобы такого небыло нужно прописать
required равным false, чтобы установить значение по умолчанию нужно прописать defaultValue
@RequestParam(value = "name", required = false, defaultValue="World")

	Модель


- Контейнер для данных нашего приложения
чтобы получить доступ к модели в контроллере нужно просто её принимать
@Controller
public String helloPage(Model model){
	model.addAttribute("key", "value");
	return "hello";
}
Передать значение из котроллера в модель можно вызвав для модели функцию .addAttribute(),
передав в неё данные в виде ключ = значение.
В html это значение вставляется при помощи th:text="${key}". Текст внутри должен быть в 
одинарных кавычках


	CRUD

Стандартная классификация функций по манипуляции данными
				Create
Четыре базовые функции,		Read
используемые при работе		Update
с базами данных:		Delete
Большинство Web - приложений - CRUD приложения
Пример CRUD'a для сущности Post
	HTTP метод	|	URL		 |	Действие
________________________|________________________|_________________________
	    GET		          /posts		Получаем все записи(READ)
	    POST		  /posts		Создаём новую запись(CREATE)
	    GET			  /posts/new		HTML форма создания записи
	    GET			/posts/:id/edit		HTML форма для редактирования записи
	    GET			  /posts/:id		Получаем одну запись(READ)
	    PATCH 		  /posts/:id		Обновляем запись(UPDATE)
	    DELETE		  /posts/:id		Удаляем запись(DELETE)

	REST

-причина, по каторой URL выше выглядят, как выглядят.
REST - это потерн проектирования web-приложений
REST отписывает то, как посредством протокола HTTP должен взаимодействовать клиент с сервером
Всё взаимодействие с сервером сводится к 4 операциям: 1) Получение данных
						      2) Добавление новых данных
						      3) Изменение существующих данных
						      4) удаление данных
для каждой операции есть свой HTTP метод - GET, POST, PATCH, DELETE соответственно.
Резюме.
CRUD - 4 базовые функции, используемы при работе с базами данных
REST - патерн проектирования web-приложений. Описывает, как по протоколу HTTP взаимодейство-
вать с сервером для получения,добавления,изменения, удаления данных. Описывает, какие URL'ы
, HTTP методы использовать(и ещё много чего)  
Связь между REST и CRUD:
GET		/user		READ
GET		/user/:id	READ
POST		/user		CREATE
PATCH		/user/:id	UPDATE
DELETE		/user/:id	DELETE


	DAO(Data Access Object)


Мы хотим вынести логику взаимодействия с <L из самой модели в отдельный класс. Паттерн 
проектирования, когда отдельный класс занимается взаимодействием с БД для конкретной сущности
называется DAO.
Так для класса Person будет создан класс PersonDAO, в который инкапсулируется вся логика 
работы с БД. В DAO классах обычно пишется SQl код для работы с БД приложения. Есть ещё 
паттерн репозиторий, который предоставляет ещё большую абстракцию над БД, чем DAO.

@GetMapping("/{id}")
    public String show(@PathVariable("id")){
        return null;
    }
данная конструкция означает, что вместо id туда может быть переданно любое число, которое
в дальнейшем при помощи @PathVariable("id") мы получаем


@ModelAttribute - работает по розному, в зависимости от того, что аннотирует
1) Метод
В каждую модель в каждом методе текущего контроллера мы хотим добавить пару ключ = значение
@ModelAttribute("headerMsg")
public String popularMsg(){
	return "Welcome"
}
в каждой модели появится пара headerMsg = "Welcome".
Может добавлять в модель любой объект.

2) Аргумент метода
берёт на себя создание нового объекта, добавление значений в поля при помощи сетеров,
добавление созданного объекта в модель

@PostMapping()
public String create(@ModelAttribute("person") Person person){
	// Добавление человека в БД
	return "successPage";
}
Если не передать в POST запросе значения будет создан объект со значениями полей по умолчанию.

Можно перенаправить при помощи redirect
@PostMapping()
public String create(@ModelAttribute("person") Person person){
	personDAO.save(person);
        return "redirect:/people";
}

Детали реализации PATCH, DELETE - в HTML5 в отличии от HTTP есть только GET и POST(в HTTP ещё
есть PATCH,DELETE,PUT ...) поэтому PATCH, DELETE, PUT запросы передаются с помощью POST, а в
скрытом поле _method указывается желаемый HTTP метод.
<form method="POST" action="/people">
    <input type="hidden"      - говорим о том, что поле скрытое
	   name="_method"     - говорим, что это за поле
	   value="patch">     - говорим, какое значение должно быть в этом поле(нужная опер.)
На стороне Spring приложения эта проблема решается при помощи фильтра. Фильтр - щбъект, кото-
рый перехватывает все входящие HTTP запросы. В данном случае фильтр используется для того, 
чтобы смотреть на значение поля _method в поступающих HTTP запросах. Можно подключать вручную,
можноподключать при помощи Spring Boot, написав одну строку в конфигурационном файле.



Restful приложение
Hibernate
soap



















































































<bean id="classicalMusicBean"
          class="org.example.ClassicalMusic"
          init-method="doMyInit"
          destroy-method="doMyDestroy"
          factory-method="getClassicalMusic"
          >
    </bean>


гриль бесконтактный
мощность от 1800
рили изготавливают из:

1. Металла— материал наиболее предпочтительный для дома, так как 
меньше подвержен ударам, сколам и царапинам, но нагревается достаточно сильно.

2. Натуральный камень — гриль может быть частично изготовлен из 
этого природного материала. Обычно это открытые модели. Камень хорош во 
всех отношениях, кроме стоимости — она немного выше.

3. Термопластик— наиболее предпочтительный вариант материала, если 
ориентироваться на термоизолированность корпуса прибора.




